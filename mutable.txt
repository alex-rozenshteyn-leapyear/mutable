-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Piecewise-mutable references for product types
--   
--   Please see the README on GitHub at
--   <a>https://github.com/mstksg/mutable#readme</a>
@package mutable
@version 0.1.0.0


-- | Abstract over different types for piecewise-mutable references of
--   values. Think of these as
module Data.Mutable.Class

-- | An instance of <tt><a>Mutable</a> m a</tt> means that <tt>a</tt> can
--   be stored a mutable reference in monad <tt>m</tt>.
--   
--   The associated type <tt><a>Ref</a> m a</tt> links any <tt>a</tt> to
--   the type of its canonical mutable version.
--   
--   The <i>benefit</i> of this typeclass, instead of just using
--   <a>IORef</a> or <a>MutVar</a> or specific mutable versions like
--   <a>Vector</a> and <a>MVector</a>, is two-fold:
--   
--   <ul>
--   <li>Piecewise-mutable values, so you can write to only one part and
--   not others. This also allows for cheaper "writes", even if you replace
--   the whole value: you don't need to ever synthesize an entire new
--   value, you can keep each component in a separate variable until you
--   <a>freezeRef</a> it out.</li>
--   <li>Generic abstractions (similar to <a>Show</a>), so you can
--   automatically derive instances while preserving piecewise-ness. For
--   example, the instance<pre>instance (Mutable m a, Mutable m b) =&gt;
--   Mutable m (a, b) </pre>If <tt>a</tt> and <tt>b</tt> are
--   piecwise-mutable, then the instance here will appropriately utilize
--   that fact.</li>
--   </ul>
--   
--   There are facilities to automatically piecewise mutable versions for
--   user-defined instances of <a>Generic</a>.
--   
--   For example, if we have a type like:
--   
--   <pre>
--   data TwoVectors = TV
--       { tvInt    :: <a>Vector</a> Int
--       , tvDouble :: Vector Double
--       }
--     deriving Generic
--   
--   instance Mutable m TwoVectors where
--       type Ref m Foo = <a>GRef</a> m TwoVectors
--   </pre>
--   
--   Then now we get:
--   
--   <pre>
--   <a>thawRef</a>   :: TwoVectors -&gt; m (<a>GRef</a> m TwoVectors)
--   <a>freezeRef</a> :: <a>GRef</a> m TwoVectors -&gt; m TwoVectors
--   </pre>
--   
--   And <tt><a>GRef</a> m TwoVectors</tt> is now a piecewise-mutable
--   reference storing each part in a way that can be modified separately
--   (for example, with tools from <a>Data.Mutable.MutPart</a>). It does
--   this by internally allocating two <a>MVector</a>s. If the two vectors
--   are large, this can be much more efficient to modify (if you are
--   modifying <i>several times</i>) than by just doing alterations on
--   <tt>TwoVector</tt>s.
--   
--   If you are using the "higher-kinded" data pattern, a la
--   <a>https://reasonablypolymorphic.com/blog/higher-kinded-data/</a>,
--   then we can also do:
--   
--   <pre>
--   data TwoVectors f = TV
--        { tvInt    :: <a>HKD</a> f (<a>Vector</a> Int)
--        , tvDouble :: HKD f (Vector Double)
--        }
--     deriving Generic
--   
--   instance Mutable (TwoVectors <a>Identity</a>) where
--       type Ref (TwoVectors <a>Identity</a>) = TwoVectors (<a>RefFor</a> m)
--   </pre>
--   
--   And now your mutable ref is literally going to be a product of the
--   components
--   
--   <pre>
--   ghci&gt; tvr@(TV is ds) &lt;- thawRef (TV xs ys)
--   ghci&gt; :t tvr
--   TV (<a>RefFor</a> IO)
--   ghci&gt; :t is
--   <a>MVector</a> RealWorld Int
--   ghci&gt; :t ds
--   <a>MVector</a> RealWorld Double
--   </pre>
--   
--   So <a>thawRef</a> will actually just get you the same record type but
--   with the mutable versions of each field.
class Monad m => Mutable m a where {
    
    -- | Links the type <tt>a</tt> to the type of its canonical mutable
    --   version.
    --   
    --   For example, for <a>Vector</a>, the mutable version is <a>MVector</a>,
    --   so we have
    --   
    --   <pre>
    --   type Ref m (<a>Vector</a> a) = <a>MVector</a> (<a>PrimState</a> m) a
    --   </pre>
    --   
    --   This means that using <a>thawRef</a> on a <a>Vector</a> will give you
    --   an <a>MVector</a>, using <a>freezeRef</a> on a <a>Vector</a> will give
    --   you a <a>Vector</a>, etc.
    --   
    --   <pre>
    --   <a>thawRef</a>
    --       :: (<a>PrimMonad</a> m, s ~ <a>PrimState</a> m)
    --       =&gt; <a>Vector</a> a
    --       -&gt; m (<a>Vector</a> s a)
    --   
    --   <a>freezeRef</a>
    --       :: (<a>PrimMonad</a> m, s ~ <a>PrimState</a> m)
    --       =&gt; <a>Vector</a> s a
    --       -&gt; m (<a>Vector</a> a)
    --   
    --   <a>copyRef</a>
    --       :: (<a>PrimMonad</a> m, s ~ <a>PrimState</a> m)
    --       =&gt; <a>Vector</a> s a
    --       -&gt; <a>Vector</a> a
    --       -&gt; m ()
    --   </pre>
    --   
    --   This associated type must be unique for <tt>a</tt>, so no two types
    --   <tt>a</tt> can have the same <tt><a>Ref</a> m a</tt>. This makes type
    --   inference a lot more useful: if you use <a>freezeRef</a> on an
    --   <a>MVector</a>, for instance, the return type will be inferred to be
    --   <a>Vector</a>.
    --   
    --   The <i>default</i> instance is just a plain old <a>MutVar</a>
    --   containing the type. This is a valid instance, but it treats the
    --   entire type "wholesale" --- it is basically using it as a non-mutable
    --   type. You won't get any of the performance benefits of piecewise
    --   mutation from it, but it is useful as a base case for non-composite
    --   types like <a>Int</a>.
    --   
    --   There are some built-in alternative options for user-defined ADTs with
    --   <a>Generic</a> instances:
    --   
    --   <pre>
    --   -- Works for all <a>Generic</a> instances, preserves piecewise mutation
    --   -- for products
    --   type Ref m a = <a>GRef</a> m a
    --   
    --   -- Works for "higher-kinded" data types, a la
    --   -- <a>https://reasonablypolymorphic.com/blog/higher-kinded-data/</a>
    --   type Ref m (z <a>Identity</a>) = z (<a>RefFor</a> m)
    --   </pre>
    --   
    --   If you just set up a blank instance, the implementations of
    --   <a>thawRef</a>, <a>freezeRef</a>, and <a>copyRef</a> will be inferred
    --   using <a>DefaultMutable</a>.
    --   
    --   <pre>
    --   -- | any <a>Generic</a> instance
    --   data Foo = Foo { fInt :: Int, fDouble :: Double }
    --     deriving Generic
    --   
    --   instance Mutable m Foo where
    --       type Ref m Foo = <a>GRef</a> m Foo
    --   
    --   -- | HKD pattern types
    --   data Bar f = Bar { bInt :: f Int, bDouble :: f Double }
    --     deriving Generic
    --   
    --   instance Mutable (Bar Identity) where
    --       type Ref (Bar Identity) = Bar (<a>RefFor</a> m)
    --   </pre>
    type family Ref m a = (v :: Type) | v -> a;
    type Ref m a = MutVar (PrimState m) a;
}

-- | <a>Thaw</a> a pure/persistent value into its mutable version, which
--   can be manipulated using <a>modifyRef</a> or other methods specific
--   for that type (like <a>read</a>).
--   
--   Returns the <a>Ref</a> instance, so, for example, for <a>Vector</a>:
--   
--   <pre>
--   <a>thawRef</a>
--       :: (<a>PrimMonad</a> m, s ~ <a>PrimState</a> m)
--       =&gt; <a>Vector</a> a
--       -&gt; m (<a>Vector</a> s a)
--   </pre>
--   
--   For non-composite (like <a>Int</a>), this is often called the "new
--   var" function, like <a>newIORef</a> / <a>newSTRef</a> /
--   <a>newMutVar</a> etc.
thawRef :: Mutable m a => a -> m (Ref m a)

-- | <a>Freeze</a> a mutable value into its pure/persistent version.
--   
--   Takes a <a>Ref</a> instance, but type inference will be able to infer
--   the pure value's type because <a>Ref</a> is injective.
--   
--   For example, for <a>Vector</a>:
--   
--   <pre>
--   <a>freezeRef</a>
--       :: (<a>PrimMonad</a> m, s ~ <a>PrimState</a> m)
--       =&gt; <a>Vector</a> s a
--       -&gt; m (<a>Vector</a> a)
--   </pre>
--   
--   For non-composite (like <a>Int</a>), this is often called the "read
--   var" function, like <a>readIORef</a> / <a>readSTRef</a> /
--   <a>readMutVar</a> etc.
freezeRef :: Mutable m a => Ref m a -> m a

-- | Overwrite a mutable value by provivding a pure/persistent value.
--   <a>copyRef</a>
--   
--   Returns the <a>Ref</a> and the value, so, for example, for
--   <a>Vector</a>:
--   
--   <pre>
--   <a>copyRef</a>
--       :: (<a>PrimMonad</a> m, s ~ <a>PrimState</a> m)
--       =&gt; <a>Vector</a> s a
--       -&gt; <a>Vector</a> a
--       -&gt; m ()
--   </pre>
--   
--   Note that if <tt>a</tt> is a composite type (with an appropriate
--   composite reference), this will be done "piecewise": it'll write to
--   each mutable component separately.
--   
--   For non-composite (like <a>Int</a>), this is often called the "write
--   var" function, like <a>writeIORef</a> / <a>writeSTRef</a> /
--   <a>writeMutVar</a> etc.
copyRef :: Mutable m a => Ref m a -> a -> m ()

-- | <a>Thaw</a> a pure/persistent value into its mutable version, which
--   can be manipulated using <a>modifyRef</a> or other methods specific
--   for that type (like <a>read</a>).
--   
--   Returns the <a>Ref</a> instance, so, for example, for <a>Vector</a>:
--   
--   <pre>
--   <a>thawRef</a>
--       :: (<a>PrimMonad</a> m, s ~ <a>PrimState</a> m)
--       =&gt; <a>Vector</a> a
--       -&gt; m (<a>Vector</a> s a)
--   </pre>
--   
--   For non-composite (like <a>Int</a>), this is often called the "new
--   var" function, like <a>newIORef</a> / <a>newSTRef</a> /
--   <a>newMutVar</a> etc.
thawRef :: (Mutable m a, DefaultMutable m a (Ref m a)) => a -> m (Ref m a)

-- | <a>Freeze</a> a mutable value into its pure/persistent version.
--   
--   Takes a <a>Ref</a> instance, but type inference will be able to infer
--   the pure value's type because <a>Ref</a> is injective.
--   
--   For example, for <a>Vector</a>:
--   
--   <pre>
--   <a>freezeRef</a>
--       :: (<a>PrimMonad</a> m, s ~ <a>PrimState</a> m)
--       =&gt; <a>Vector</a> s a
--       -&gt; m (<a>Vector</a> a)
--   </pre>
--   
--   For non-composite (like <a>Int</a>), this is often called the "read
--   var" function, like <a>readIORef</a> / <a>readSTRef</a> /
--   <a>readMutVar</a> etc.
freezeRef :: (Mutable m a, DefaultMutable m a (Ref m a)) => Ref m a -> m a

-- | Overwrite a mutable value by provivding a pure/persistent value.
--   <a>copyRef</a>
--   
--   Returns the <a>Ref</a> and the value, so, for example, for
--   <a>Vector</a>:
--   
--   <pre>
--   <a>copyRef</a>
--       :: (<a>PrimMonad</a> m, s ~ <a>PrimState</a> m)
--       =&gt; <a>Vector</a> s a
--       -&gt; <a>Vector</a> a
--       -&gt; m ()
--   </pre>
--   
--   Note that if <tt>a</tt> is a composite type (with an appropriate
--   composite reference), this will be done "piecewise": it'll write to
--   each mutable component separately.
--   
--   For non-composite (like <a>Int</a>), this is often called the "write
--   var" function, like <a>writeIORef</a> / <a>writeSTRef</a> /
--   <a>writeMutVar</a> etc.
copyRef :: (Mutable m a, DefaultMutable m a (Ref m a)) => Ref m a -> a -> m ()

-- | Apply a pure function on an immutable value onto a value stored in a
--   mutable reference.
modifyRef :: Mutable m a => Ref m a -> (a -> a) -> m ()

-- | <a>modifyRef</a>, but forces the result before storing it back in the
--   reference.
modifyRef' :: Mutable m a => Ref m a -> (a -> a) -> m ()

-- | Apply a pure function on an immutable value onto a value stored in a
--   mutable reference, returning a result value from that function.
updateRef :: Mutable m a => Ref m a -> (a -> (a, b)) -> m b

-- | <a>updateRef</a>, but forces the updated value before storing it back
--   in the reference.
updateRef' :: Mutable m a => Ref m a -> (a -> (a, b)) -> m b

-- | Newtype wrapper that can provide any type with a <a>Mutable</a>
--   instance. Can be useful for avoiding orphan instances.
newtype MutRef a
MutRef :: a -> MutRef a
[getMutRef] :: MutRef a -> a

-- | A handy newtype wrapper that allows you to partially apply <a>Ref</a>.
--   <tt><a>RefFor</a> m a</tt> is the same as <tt><a>Ref</a> m a</tt>, but
--   can be partially applied.
--   
--   If used with <a>HKD</a>, you can treat this syntactically identically
--   as a <tt><a>Ref</a> m a</tt>.
newtype RefFor m a
RefFor :: Ref m a -> RefFor m a
[getRefFor] :: RefFor m a -> Ref m a

-- | The default implementations of <a>thawRef</a>, <a>freezeRef</a>, and
--   <a>copyRef</a> dispatched for different choices of <a>Ref</a>.
--   
--   Basically, by specifying <a>Ref</a>, you get the rest of the instance
--   for free.
--   
--   <pre>
--   -- default, if you don't specify <a>Ref</a>
--   instance Mutable m MyType
--   
--   -- the above is the same as:
--   instance Mutable m MyType
--       type Ref m MyType = MutVar (PrimState m) MyType
--   
--   -- or if we have an instance of <a>Generic</a>:
--   instance Mutable m MyType
--       type Ref m MyType = GRef m MyType
--   
--   -- or, using the higher-kinded data pattern, like
--   -- <a>https://reasonablypolymorphic.com/blog/higher-kinded-data/</a>
--   instance Mutable m (MyTypeF Identity)
--       type Ref m (MyTypeF Identity) = MyTypeF (RefFor m)
--   </pre>
class DefaultMutable m a r
defaultThawRef :: DefaultMutable m a r => a -> m r
defaultFreezeRef :: DefaultMutable m a r => r -> m a
defaultCopyRef :: DefaultMutable m a r => r -> a -> m ()

-- | Automatically generate a piecewise mutable reference for any
--   <a>Generic</a> instance.
--   
--   <pre>
--   -- | any <a>Generic</a> instance
--   data Foo = Foo { fInt :: Int, fDouble :: Double }
--     deriving (Generic, Show)
--   
--   instance Mutable m Foo where
--       type Ref m Foo = <a>GRef</a> m Foo
--   </pre>
--   
--   <pre>
--   ghci&gt; r &lt;- <a>thawRef</a> (Foo 3 4.5)
--   ghci&gt; <a>freezeRef</a> r
--   Foo 3 4.5
--   ghci&gt; <a>freezePart</a> (<a>fieldMut</a> #fInt) r
--   3
--   ghci&gt; <a>copyPart</a> (fieldMut #fDouble) 1.23
--   ghci&gt; freezeRef r
--   Foo 3 1.23
--   </pre>
--   
--   Note that this is basically just a bunch of tupled refs for a product
--   type. For a sum type (with multiple constructors), an extra layer of
--   indirection is added to account for the dynamically changable shape.
--   
--   See <a>FieldMut</a>/<a>PosMot</a> for ways to inspect and mutate the
--   internals of this type (as demonstrated above).
newtype GRef m a
GRef :: GRef_ m (Rep a) () -> GRef m a
[unGRef] :: GRef m a -> GRef_ m (Rep a) ()

-- | Default <a>thawRef</a> for <a>GRef</a>.
--   
--   You likely won't ever use this directly, since it is automatically
--   provided if you have a <a>Mutable</a> instance with <a>GRef</a> as the
--   <a>Ref</a>. However, it can be useful if you are using a
--   <tt><a>GRef</a> m a</tt> just as a normal data type, independent of
--   the <a>Ref</a> class. See documentation for <a>GRef</a> for more
--   information.
gThawRef :: (Generic a, GMutable m (Rep a)) => a -> m (GRef m a)

-- | Default <a>freezeRef</a> for <a>GRef</a>.
--   
--   You likely won't ever use this directly, since it is automatically
--   provided if you have a <a>Mutable</a> instance with <a>GRef</a> as the
--   <a>Ref</a>. However, it can be useful if you are using a
--   <tt><a>GRef</a> m a</tt> just as a normal data type, independent of
--   the <a>Ref</a> class. See documentation for <a>GRef</a> for more
--   information.
gFreezeRef :: (Generic a, GMutable m (Rep a)) => GRef m a -> m a

-- | Default <a>copyRef</a> for <a>GRef</a>.
--   
--   You likely won't ever use this directly, since it is automatically
--   provided if you have a <a>Mutable</a> instance with <a>GRef</a> as the
--   <a>Ref</a>. However, it can be useful if you are using a
--   <tt><a>GRef</a> m a</tt> just as a normal data type, independent of
--   the <a>Ref</a> class. See documentation for <a>GRef</a> for more
--   information.
gCopyRef :: (Generic a, GMutable m (Rep a)) => GRef m a -> a -> m ()

-- | Class for automatic generation of <a>Ref</a> for <a>Generic</a>
--   instances. See <a>GRef</a> for more information.
class Monad m => GMutable m f where {
    type family GRef_ m f = (u :: Type -> Type) | u -> f;
}

-- | Default <a>copyRef</a> for the higher-kinded data pattern, a la
--   <a>https://reasonablypolymorphic.com/blog/higher-kinded-data/</a>.
--   
--   You likely won't ever use this directly, since it is automatically
--   provided if you have a <a>Mutable</a> instance with <tt>z
--   (<a>RefFor</a> m)</tt> as the <a>Ref</a>. However, it can be useful if
--   you are using a <tt>z (<a>RefFor</a> m)</tt> just as a normal data
--   type, independent of the <a>Ref</a> class. See documentation for
--   <a>Mutable</a> for more information.
thawHKD :: forall z m. (Generic (z Identity), Generic (z (RefFor m)), GMutable m (Rep (z Identity)), GRef_ m (Rep (z Identity)) ~ Rep (z (RefFor m))) => z Identity -> m (z (RefFor m))

-- | Default <a>freezeRef</a> for the higher-kinded data pattern, a la
--   <a>https://reasonablypolymorphic.com/blog/higher-kinded-data/</a>.
--   
--   You likely won't ever use this directly, since it is automatically
--   provided if you have a <a>Mutable</a> instance with <tt>z
--   (<a>RefFor</a> m)</tt> as the <a>Ref</a>. However, it can be useful if
--   you are using a <tt>z (<a>RefFor</a> m)</tt> just as a normal data
--   type, independent of the <a>Ref</a> class. See documentation for
--   <a>Mutable</a> for more information.
freezeHKD :: forall z m. (Generic (z Identity), Generic (z (RefFor m)), GMutable m (Rep (z Identity)), GRef_ m (Rep (z Identity)) ~ Rep (z (RefFor m))) => z (RefFor m) -> m (z Identity)

-- | Default <a>copyRef</a> for the higher-kinded data pattern, a la
--   <a>https://reasonablypolymorphic.com/blog/higher-kinded-data/</a>.
--   
--   You likely won't ever use this directly, since it is automatically
--   provided if you have a <a>Mutable</a> instance with <tt>z
--   (<a>RefFor</a> m)</tt> as the <a>Ref</a>. However, it can be useful if
--   you are using a <tt>z (<a>RefFor</a> m)</tt> just as a normal data
--   type, independent of the <a>Ref</a> class. See documentation for
--   <a>Mutable</a> for more information.
copyHKD :: forall z m. (Generic (z Identity), Generic (z (RefFor m)), GMutable m (Rep (z Identity)), GRef_ m (Rep (z Identity)) ~ Rep (z (RefFor m))) => z (RefFor m) -> z Identity -> m ()

-- | <a>Ref</a> for components in a vinyl <a>Rec</a>.
newtype RecRef m f a
RecRef :: Ref m (f a) -> RecRef m f a
[recRef] :: RecRef m f a -> Ref m (f a)

-- | If you can provice a natural transformation from <tt>m</tt> to
--   <tt>n</tt>, you should be able to use a value as if it had
--   <tt><a>Mutable</a> n a</tt> if you have <tt><a>Mutable</a> m a</tt>.
reMutable :: forall m n a r. (Mutable m a, Monad n) => (forall x. m x -> n x) -> (Mutable n a => r) -> r

-- | If you can provice a natural transformation from <tt>m</tt> to
--   <tt>n</tt>, then <tt><a>Mutable</a> m a</tt> should also imply
--   <tt><a>Mutable</a> n a</tt>.
reMutableConstraint :: forall m n a. (Mutable m a, Monad n) => (forall x. m x -> n x) -> Mutable m a :- Mutable n a
instance (GHC.Base.Monad n, Data.Mutable.Class.Mutable m a, Data.Reflection.Reifies s (Data.Mutable.Class.ReMutableTrans m n)) => Data.Mutable.Class.Mutable n (Data.Mutable.Class.ReMutable s m a)
instance (GHC.Generics.Generic a, Data.Mutable.Class.GMutable m (GHC.Generics.Rep a)) => Data.Mutable.Class.DefaultMutable m a (Data.Mutable.Class.GRef m a)
instance (GHC.Generics.Generic (z Data.Vinyl.Functor.Identity), GHC.Generics.Generic (z (Data.Mutable.Class.RefFor m)), Data.Mutable.Class.GMutable m (GHC.Generics.Rep (z Data.Vinyl.Functor.Identity)), Data.Mutable.Class.GRef_ m (GHC.Generics.Rep (z Data.Vinyl.Functor.Identity)) GHC.Types.~ GHC.Generics.Rep (z (Data.Mutable.Class.RefFor m))) => Data.Mutable.Class.DefaultMutable m (z Data.Vinyl.Functor.Identity) (z (Data.Mutable.Class.RefFor m))
instance Data.Mutable.Class.Mutable m c => Data.Mutable.Class.GMutable m (GHC.Generics.K1 i c)
instance GHC.Base.Monad m => Data.Mutable.Class.GMutable m GHC.Generics.U1
instance GHC.Base.Monad m => Data.Mutable.Class.GMutable m GHC.Generics.V1
instance (Data.Mutable.Class.GMutable m f, Data.Mutable.Class.GMutable m g) => Data.Mutable.Class.GMutable m (f GHC.Generics.:*: g)
instance Data.Mutable.Class.GMutable m f => Data.Mutable.Class.GMutable m (GHC.Generics.M1 i c f)
instance (Data.Mutable.Class.GMutable m f, Data.Mutable.Class.GMutable m g, Control.Monad.Primitive.PrimMonad m) => Data.Mutable.Class.GMutable m (f GHC.Generics.:+: g)
instance forall u (m :: * -> *) (f :: u -> *). GHC.Base.Monad m => Data.Mutable.Class.Mutable m (Data.Vinyl.Core.Rec f '[])
instance forall a1 (m :: * -> *) (f :: a1 -> *) (a2 :: a1) (as :: [a1]). (GHC.Base.Monad m, Data.Mutable.Class.Mutable m (f a2), Data.Mutable.Class.Mutable m (Data.Vinyl.Core.Rec f as), Data.Mutable.Class.Ref m (Data.Vinyl.Core.Rec f as) GHC.Types.~ Data.Vinyl.Core.Rec (Data.Mutable.Class.RecRef m f) as) => Data.Mutable.Class.Mutable m (Data.Vinyl.Core.Rec f (a2 : as))
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m (Data.Mutable.Class.MutRef a)
instance Data.Vinyl.XRec.IsoHKD Data.Mutable.Class.MutRef a
instance Data.Vinyl.XRec.IsoHKD (Data.Mutable.Class.RefFor m) a
instance Data.Mutable.Class.Mutable m a => Data.Mutable.Class.Mutable m (Data.Vinyl.Functor.Identity a)
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m GHC.Types.Int
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m GHC.Integer.Type.Integer
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m (GHC.Real.Ratio a)
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m GHC.Types.Float
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m GHC.Types.Double
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m (Data.Complex.Complex a)
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m GHC.Types.Bool
instance Control.Monad.Primitive.PrimMonad m => Data.Mutable.Class.Mutable m (Data.Vector.Vector a)
instance (Control.Monad.Primitive.PrimMonad m, Foreign.Storable.Storable a) => Data.Mutable.Class.Mutable m (Data.Vector.Storable.Vector a)
instance (Control.Monad.Primitive.PrimMonad m, Data.Vector.Unboxed.Base.Unbox a) => Data.Mutable.Class.Mutable m (Data.Vector.Unboxed.Base.Vector a)
instance (Control.Monad.Primitive.PrimMonad m, Data.Primitive.Types.Prim a) => Data.Mutable.Class.Mutable m (Data.Vector.Primitive.Vector a)
instance GHC.Base.Monad m => Data.Mutable.Class.Mutable m ()
instance (GHC.Base.Monad m, Data.Mutable.Class.Mutable m a, Data.Mutable.Class.Mutable m b) => Data.Mutable.Class.Mutable m (a, b)
instance (GHC.Base.Monad m, Data.Mutable.Class.Mutable m a, Data.Mutable.Class.Mutable m b, Data.Mutable.Class.Mutable m c) => Data.Mutable.Class.Mutable m (a, b, c)
instance (GHC.Base.Monad m, Data.Mutable.Class.Mutable m a, Data.Mutable.Class.Mutable m b, Data.Mutable.Class.Mutable m c, Data.Mutable.Class.Mutable m d) => Data.Mutable.Class.Mutable m (a, b, c, d)
instance (Control.Monad.Primitive.PrimMonad m, s GHC.Types.~ Control.Monad.Primitive.PrimState m) => Data.Mutable.Class.DefaultMutable m a (Data.Primitive.MutVar.MutVar s a)


-- | Tools for working with individual components of piecewise-mutable
--   values. Think of these as being
module Data.Mutable.MutPart

-- | A <tt><a>MutPart</a> m s a</tt> is a way to "zoom into" an <tt>a</tt>,
--   as a part of a mutable reference on <tt>s</tt>. This allows you to
--   only modify a single <tt>a</tt> part of the <tt>s</tt>, without
--   touching the rest.
--   
--   An example that is commonly found in the ecosystem is something like
--   (flipped) <tt>write :: Int -&gt; <a>MVector</a> s a -&gt; a -&gt; m
--   ()</tt> from <a>Data.Vector.Mutable</a> --- <tt>write 3 ::
--   <a>MVector</a> s a -&gt; a -&gt; m ()</tt>, for instance, lets you
--   modify a specific part of the vector without touching the rest.
--   
--   You would <i>use</i> a <a>MutPart</a> using <a>freezePart</a>,
--   <a>copyPart</a>, <a>modifyPart</a>, etc.
--   
--   For non-composite types, there won't really be any meaningful values.
--   However, we have them for many composite types. For example, for
--   tuples:
--   
--   <pre>
--   <a>mutFst</a> :: <a>MutPart</a> m (a, b) a
--   <a>mutSnd</a> :: MutPart m (a, b) b
--   </pre>
--   
--   <pre>
--   ghci&gt; r &lt;- <a>thawRef</a> (2, 4)
--   ghci&gt; <a>copyPart</a> mutFst r 100
--   ghci&gt; <a>freezeRef</a> r
--   (100, 4)
--   </pre>
--   
--   If you are using <a>GRef</a> as an automatically-defined mutable
--   reference, then the easiest way to create these for your mutable types
--   are with <a>fieldMut</a> and <a>posMut</a>.
--   
--   If you are using the "Higher-kinded data" pattern, then there's an
--   easy way to generate a <a>MutPart</a> for every single field, if you
--   have a product type --- see <a>hkdMutParts</a> for more information.
newtype MutPart m s a
MutPart :: (Ref m s -> Ref m a) -> MutPart m s a
[getMutPart] :: MutPart m s a -> Ref m s -> Ref m a

-- | With a <a>MutPart</a>, read out a specific part of a <a>Ref</a>.
freezePart :: Mutable m a => MutPart m s a -> Ref m s -> m a

-- | With a <a>MutPart</a>, overwrite into a specific part of a <a>Ref</a>.
copyPart :: Mutable m a => MutPart m s a -> Ref m s -> a -> m ()

-- | With a <a>MutPart</a>, modify a specific part of a <a>Ref</a> with a
--   pure function.
modifyPart :: Mutable m a => MutPart m s a -> Ref m s -> (a -> a) -> m ()

-- | <a>modifyPart</a>, but forces the result before storing it back in the
--   reference.
modifyPart' :: Mutable m a => MutPart m s a -> Ref m s -> (a -> a) -> m ()

-- | <a>updateRef</a>, under a <a>MutPart</a> to only modify a specific
--   part of a <a>Ref</a>.
updatePart :: Mutable m a => MutPart m s a -> Ref m s -> (a -> (a, b)) -> m b

-- | <a>updatePart</a>, but forces the result before storing it back in the
--   reference.
updatePart' :: Mutable m a => MutPart m s a -> Ref m s -> (a -> (a, b)) -> m b

-- | <a>MutPart</a> into the first field of a tuple reference.
mutFst :: MutPart m (a, b) a

-- | <a>MutPart</a> into the second field of a tuple reference.
mutSnd :: MutPart m (a, b) b

-- | Create a <a>MutPart</a> for a field name. Should work for any type
--   with one constructor whose mutable reference is <a>GRef</a>. See
--   <a>fieldMut</a> for usage directions.
class (Mutable m s, Mutable m a) => FieldMut (fld :: Symbol) m s a | fld s -> a

-- | Create a <a>MutPart</a> for a field name. Should work for any type
--   with one constructor whose mutable reference is <a>GRef</a>.
--   
--   Is meant to be used with OverloadedLabels:
--   
--   <pre>
--   data Foo = Foo { fInt :: Int, fDouble :: Double }
--     deriving (Generic, Show)
--   
--   instance Mutable m Foo where
--       type Ref m Foo = <a>GRef</a> m Foo
--   </pre>
--   
--   <pre>
--   ghci&gt; r &lt;- <a>thawRef</a> (Foo 3 4.5)
--   ghci&gt; <a>freezePart</a> (<a>fieldMut</a> #fInt) r
--   3
--   ghci&gt; <a>copyPart</a> (fieldMut #fDouble) 1.23
--   ghci&gt; <a>freezeRef</a> r
--   Foo 3 1.23
--   </pre>
--   
--   However, you can use it without OverloadedLabels by using <a>Fld</a>
--   with TypeApplications:
--   
--   <pre>
--   ghci&gt; <a>freezePart</a> (<a>fieldMut</a> (<a>Fld</a> @"fInt")) r
--   3
--   </pre>
--   
--   This and <a>posMut</a> are the main ways to generate a <a>MutPart</a>
--   for a type whose mutable reference is <a>GRef</a>.
fieldMut :: FieldMut fld m s a => Fld fld -> MutPart m s a

-- | Used (with its <a>IsLabel</a> instance) for <a>fieldMut</a>.
data Fld (fld :: Symbol)
Fld :: Fld (fld :: Symbol)

-- | Create a <a>MutPart</a> for a position in a sum type. Should work for
--   any type with one constructor whose mutable reference is <a>GRef</a>.
--   See <a>posMut</a> for usage directions.
class (Mutable m s, Mutable m a) => PosMut (i :: Nat) m s a | i s -> a

-- | Create a <a>MutPart</a> for a position in a sum type. Should work for
--   any type with one constructor whose mutable reference is <a>GRef</a>.
--   
--   Meant to be used with TypeApplications:
--   
--   <pre>
--   data Foo = Foo Int Double
--     deriving (Generic, Show)
--   
--   instance Mutable m Foo where
--       type Ref m Foo = <a>GRef</a> m Foo
--   </pre>
--   
--   <pre>
--   ghci&gt; r &lt;- <a>thawRef</a> (Foo 3 4.5)
--   ghci&gt; <a>freezePart</a> (<a>posMut</a> <tt>1) r
--   3
--   ghci&gt; <a>copyPart</a> (posMut </tt>2) 1.23
--   ghci&gt; <a>freezeRef</a> r
--   Foo 3 1.23
--   </pre>
--   
--   This and <a>fieldMut</a> are the main ways to generate a
--   <a>MutPart</a> for a type whose mutable reference is <a>GRef</a>.
posMut :: PosMut i m s a => MutPart m s a

-- | If you are using the "higher-kinded data" pattern, a la
--   <a>https://reasonablypolymorphic.com/blog/higher-kinded-data/</a>, and
--   you have the appropriate instance for <a>Ref</a>, then you can use
--   this to generate a <a>MutPart</a> for every field, if you have a type
--   with only one constructor.
--   
--   <pre>
--   data MyTypeF f = MT
--        { fInt    :: f Int
--        , fDouble :: f Double
--        }
--     deriving Generic
--   
--   instance Mutable (MyTypeF <a>Identity</a>) where
--       type Ref (MyTypeF <a>Identity</a>) = MyTypeF (<a>RefFor</a> m)
--   
--   mx :: MutPart (MyTypeF Identity) (<a>Vector</a> Int)
--   my :: MutPart (MyTypeF Identity) (V.Vector Double)
--   MT mx my = hkdMutParts @MyTypeF
--   </pre>
--   
--   <pre>
--   ghci&gt; r &lt;- thawRef (MT 3 4.5)
--   ghci&gt; <a>freezePart</a> mx r
--   3
--   ghci&gt; <a>copyPart</a> (fDouble (hkdMutParts @MyTypeF)) r 12.3
--   ghci&gt; <a>freezeRef</a> r
--   MT 3 12.3
--   </pre>
hkdMutParts :: forall z m. (Generic (z (RefFor m)), Generic (z (MutPart m (z Identity))), HKDMutParts m z (Rep (z (RefFor m))) (Rep (z (MutPart m (z Identity))))) => z (MutPart m (z Identity))
instance GHC.Show.Show (Data.Mutable.MutPart.Fld fld)
instance (Data.Mutable.Class.Mutable m s, Data.Mutable.Class.Mutable m a, Data.Mutable.Class.Ref m s GHC.Types.~ Data.Mutable.Class.GRef m s, gref GHC.Types.~ Data.Mutable.MutPart.Fst (Data.Mutable.MutPart.Traverse (Data.Mutable.Class.GRef_ m (Data.Generics.Product.Internal.Positions.CRep s)) 1), GHC.Types.Coercible (Data.Mutable.Class.GRef_ m (GHC.Generics.Rep s) ()) (gref ()), Data.Generics.Product.Internal.GLens.GLens' (Data.Mutable.MutPart.HasTotalPositionPSym i) gref (Data.Mutable.Class.Ref m a), Data.Generics.Product.Positions.HasPosition' i s a) => Data.Mutable.MutPart.PosMut i m s a
instance (Data.Mutable.Class.Mutable m s, Data.Mutable.Class.Mutable m a, Data.Mutable.Class.Ref m s GHC.Types.~ Data.Mutable.Class.GRef m s, Data.Generics.Product.Internal.GLens.GLens' (Data.Mutable.MutPart.HasTotalFieldPSym fld) (Data.Mutable.Class.GRef_ m (GHC.Generics.Rep s)) (Data.Mutable.Class.Ref m a), Data.Generics.Product.Fields.HasField' fld s a) => Data.Mutable.MutPart.FieldMut fld m s a
instance (s GHC.Types.~ s') => GHC.OverloadedLabels.IsLabel s (Data.Mutable.MutPart.Fld s')
instance (Data.Mutable.Class.Mutable m (z Data.Vinyl.Functor.Identity), Data.Mutable.Class.Ref m (z Data.Vinyl.Functor.Identity) GHC.Types.~ z (Data.Mutable.Class.RefFor m)) => Data.Mutable.MutPart.HKDMutParts m z (GHC.Generics.K1 i (Data.Mutable.Class.RefFor m c)) (GHC.Generics.K1 i (Data.Mutable.MutPart.MutPart m (z Data.Vinyl.Functor.Identity) c))
instance (Data.Mutable.Class.Mutable m (z Data.Vinyl.Functor.Identity), Data.Mutable.Class.Ref m (z Data.Vinyl.Functor.Identity) GHC.Types.~ z (Data.Mutable.Class.RefFor m)) => Data.Mutable.MutPart.HKDMutParts m z GHC.Generics.U1 GHC.Generics.U1
instance (Data.Mutable.Class.Mutable m (z Data.Vinyl.Functor.Identity), Data.Mutable.Class.Ref m (z Data.Vinyl.Functor.Identity) GHC.Types.~ z (Data.Mutable.Class.RefFor m), (TypeError ...)) => Data.Mutable.MutPart.HKDMutParts m z GHC.Generics.V1 GHC.Generics.V1
instance forall k (m :: * -> *) (z :: (* -> *) -> *) (i :: k -> *) (o :: k -> *) a (b :: GHC.Generics.Meta). Data.Mutable.MutPart.HKDMutParts m z i o => Data.Mutable.MutPart.HKDMutParts m z (GHC.Generics.M1 a b i) (GHC.Generics.M1 a b o)
instance forall k (m :: * -> *) (z :: (* -> *) -> *) (i :: k -> *) (o :: k -> *) (i' :: k -> *) (o' :: k -> *). (Data.Mutable.MutPart.HKDMutParts m z i o, Data.Mutable.MutPart.HKDMutParts m z i' o') => Data.Mutable.MutPart.HKDMutParts m z (i GHC.Generics.:*: i') (o GHC.Generics.:*: o')
instance forall k (m :: * -> *) (z :: (* -> *) -> *) (i :: k -> *) (i' :: k -> *) (o :: k -> *). (Data.Mutable.Class.Mutable m (z Data.Vinyl.Functor.Identity), Data.Mutable.Class.Ref m (z Data.Vinyl.Functor.Identity) GHC.Types.~ z (Data.Mutable.Class.RefFor m), (TypeError ...)) => Data.Mutable.MutPart.HKDMutParts m z (i GHC.Generics.:+: i') o
instance Data.Vinyl.XRec.IsoHKD (Data.Mutable.MutPart.MutPart m s) a
